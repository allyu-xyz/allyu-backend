{
  "language": "Solidity",
  "sources": {
    "contracts/CryptoMoney.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nerror CryptoMoney__NotApproved();\nerror CryptoMoney__TransferFailed();\nerror CryptoMoney__CodeHashNotEmpty();\nerror CryptoMoney__FeeNotMet();\nerror CryptoMoney__InvalidCode();\nerror CryptoMoney__InvalidWord();\nerror CryptoMoney__NoFeesToWithdraw();\n\n// @title A sample Crypto Money Contract\n// @author Carlos, Jason, Sebastian\n// @notice This contract is for creating a sample Crypto Money Contract\n// @dev All functions are currently implemented without side effects\n\ncontract CryptoMoney is Ownable {\n    ///////////////////////\n    // Storage Varibles //\n    ///////////////////////\n\n    IERC20 private s_daiContract;\n    uint256 private s_feeInWeiPerBill;\n    uint256 private s_requestId;\n    mapping(uint256 => Request) private s_requestIdToRequest;\n    uint256 private s_nextBillId;\n    Bill[] private s_bills;\n\n    //////////////\n    // Structs //\n    //////////////\n\n    struct Request {\n        uint256 amountPerBill;\n        uint256 billCount;\n        bool isIssued;\n        address requester;\n    }\n\n    struct Bill {\n        uint256 id;\n        uint256 value;\n        string wordHash;\n        string codeHash;\n        bool isFunded;\n        bool isRedeemed;\n    }\n\n    /////////////\n    // Events //\n    ////////////\n\n    event NewRequest(\n        uint256 indexed requestId,\n        address indexed requester,\n        uint256 amountPerBill,\n        uint256 billCount\n    );\n    event BillIssued(uint256 indexed billId, uint256 value);\n    event BillFunded(\n        uint256 indexed billId,\n        address indexed funder,\n        uint256 value\n    );\n    event BillRedeemed(\n        uint256 indexed billId,\n        address indexed redeemer,\n        uint256 value\n    );\n\n    constructor(uint256 feePerBill, address daiContractAddress) {\n        s_nextBillId = feePerBill;\n        s_daiContract = IERC20(daiContractAddress);\n        s_nextBillId = 1;\n    }\n\n    ///////////////\n    // Functions //\n    ///////////////\n\n    // @notice Accepts payment for physical paper bills, creates a pending request object containing the amount per bills,\n    // number of bills requested, is issued boolean set to false, and the address of the requester. Iterates request Id.\n    // @param amountPerBill The amount the requester requests each bill will be worth in DAI\n    // @param billCount The total number of bills requested\n\n    function requestBills(uint256 amountPerBill, uint256 billCount)\n        external\n        payable\n    {\n        if (s_feeInWeiPerBill * billCount <= msg.value) {\n            revert CryptoMoney__FeeNotMet();\n        }\n        s_requestIdToRequest[s_requestId] = Request(\n            amountPerBill,\n            billCount,\n            false,\n            msg.sender\n        );\n        emit NewRequest(s_requestId, msg.sender, amountPerBill, billCount);\n        s_requestId++;\n    }\n\n    // @notice Issues new physical bills, bill objects are created containing the bill id, amount pulled from the request object,\n    // a blank word hash (this gets updated by the funder when bill is funded), the keccak256 hash of a secret code, and\n    // is funded and is redeemed are both set to false\n    // @param requestId the request id is used to retrieve the request\n    // @param codeHash bills are created with the keccak256 hash of a secret code, this code is hidden on the paper money\n\n    function issueBills(uint256 requestId, string[] calldata codeHash)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < codeHash.length; i++) {\n            Request memory request = s_requestIdToRequest[requestId];\n            s_bills.push(\n                Bill(\n                    s_nextBillId,\n                    request.amountPerBill,\n                    \"\",\n                    codeHash[i],\n                    false,\n                    false\n                )\n            );\n            emit BillIssued(s_nextBillId, request.amountPerBill);\n        }\n        s_requestIdToRequest[requestId].isIssued = true;\n        s_nextBillId += codeHash.length;\n    }\n\n    // @notice The buyer of the paper bills funds them with DAI by scanning the QR code on the bill and calling this function.\n    // Function makes sure that DAI is approved to be spent by the contract for the value stored in the bill object.\n    // The buyer inputs a code, which is hashed on the frontend, this is the code hash that's inputed into the function.\n    // In the bill object, the code hash is updated with inputed code hash and is funded is updated to true. DAI is transfered to this contract.\n    // The buyer finally writes the code word on the physical bill\n    // @param requestId the request id is used to retrieve the request\n    // @param codeHash bills are created with the keccak256 hash of a secret code, this code is hidden on the paper money\n\n    function fund(\n        uint256 billId,\n        uint256 amount,\n        string calldata codeHash\n    ) external {\n        Bill memory bill = s_bills[billId];\n        IERC20 daiContract = s_daiContract;\n        if (daiContract.allowance(msg.sender, address(this)) != bill.value) {\n            revert CryptoMoney__NotApproved();\n        }\n        s_bills[billId].codeHash = codeHash;\n        s_bills[billId].isFunded = true;\n        bool success = daiContract.transferFrom(\n            msg.sender,\n            address(this),\n            bill.value\n        );\n        if (!success) {\n            revert CryptoMoney__TransferFailed();\n        }\n        emit BillFunded(billId, msg.sender, amount);\n    }\n\n    // @notice The redeemer reveals the secret code which has been hidden on the paper bill and inputs it, the bill id, and the secret word which was pyhsically\n    // written onto the bill into this function. It then checks to make sure both the hash of the word and code equal the hashes stored in the bill object\n    // is redeemed is udpated on the bill object to be true and the DAI is transfered to the caller\n    // @param billId The bill id that is attempted to be redeemed\n    // @param code The secret code which was revealed on the physical bill\n    // @param word the secret word which is written on the physical bill\n\n    function redeem(\n        uint256 billId,\n        string calldata code,\n        string calldata word\n    ) external {\n        Bill memory bill = s_bills[billId];\n        if (\n            keccak256(abi.encodePacked(code)) !=\n            bytes32(abi.encodePacked(bill.codeHash))\n        ) {\n            revert CryptoMoney__InvalidCode();\n        }\n        if (\n            keccak256(abi.encodePacked(word)) !=\n            bytes32(abi.encodePacked(bill.wordHash))\n        ) {\n            revert CryptoMoney__InvalidWord();\n        }\n        s_bills[billId].isRedeemed = true;\n        bool success = s_daiContract.transfer(msg.sender, bill.value);\n        if (!success) {\n            revert CryptoMoney__TransferFailed();\n        }\n        emit BillRedeemed(bill.id, msg.sender, bill.value);\n    }\n\n    function updateFee(uint256 updatedFee) external onlyOwner {\n        s_feeInWeiPerBill = updatedFee;\n    }\n\n    function claimFees() external onlyOwner {\n        if (address(this).balance == 0) {\n            revert CryptoMoney__NoFeesToWithdraw();\n        }\n        (bool success, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        if (!success) {\n            revert CryptoMoney__TransferFailed();\n        }\n    }\n\n    /////////////////////\n    // View Functions //\n    ////////////////////\n\n    function getDaiContract() external view returns (IERC20) {\n        return s_daiContract;\n    }\n\n    function getFeePerBill() external view returns (uint256) {\n        return s_feeInWeiPerBill;\n    }\n\n    function getNextRequestId() external view returns (uint256) {\n        return s_requestId;\n    }\n\n    function getOneRequest(uint256 requestId)\n        external\n        view\n        returns (Request memory)\n    {\n        return s_requestIdToRequest[requestId];\n    }\n\n    function getNextBillId() external view returns (uint256) {\n        return s_nextBillId;\n    }\n\n    function getOneBillFromBillId(uint256 billId)\n        external\n        view\n        returns (Bill memory)\n    {\n        return s_bills[billId];\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "openzeppelin-solidity/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}